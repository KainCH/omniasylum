@using OmniForge.Core.Entities
@using OmniForge.Core.Interfaces
@inject IUserRepository UserRepository
@inject ILogger<BrokenUserManagerModal> Logger

@if (Show)
{
    <div class="modal fade show d-block" tabindex="-1" role="dialog" style="background-color: rgba(0,0,0,0.5);">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title text-warning"><i class="bi bi-exclamation-triangle-fill me-2"></i>Broken User Manager</h5>
                    <button type="button" class="btn-close" @onclick="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-warning">
                        <i class="bi bi-info-circle me-2"></i>
                        This tool identifies users with missing or corrupted data (e.g., empty TwitchUserId, missing fields, duplicate entries).
                    </div>

                    @if (isLoading)
                    {
                        <div class="text-center p-5">
                            <div class="spinner-border text-warning" role="status">
                                <span class="visually-hidden">Scanning users...</span>
                            </div>
                            <p class="mt-2 text-muted">Scanning all users for issues...</p>
                        </div>
                    }
                    else if (brokenUsers == null || !brokenUsers.Any())
                    {
                        <div class="text-center p-5 text-success">
                            <i class="bi bi-check-circle-fill fs-1 mb-3"></i>
                            <p>No broken users found! System is healthy.</p>
                        </div>
                    }
                    else
                    {
                        <div class="alert alert-danger mb-3">
                            <strong>Found @brokenUsers.Count broken user(s)</strong>
                        </div>
                        <div class="list-group list-group-flush">
                            @foreach (var user in brokenUsers)
                            {
                                <div class="list-group-item d-flex justify-content-between align-items-center">
                                    <div>
                                        <h6 class="mb-1 text-danger">
                                            @(string.IsNullOrEmpty(user.Username) ? "(No Username)" : user.Username)
                                            @if (!string.IsNullOrEmpty(user.DisplayName))
                                            {
                                                <span class="text-muted">(@user.DisplayName)</span>
                                            }
                                        </h6>
                                        <p class="mb-0 small text-muted">TwitchUserId: @(string.IsNullOrEmpty(user.TwitchUserId) ? "<empty>" : user.TwitchUserId)</p>
                                        <p class="mb-0 small text-warning"><i class="bi bi-exclamation-triangle"></i> @user.IssueDescription</p>
                                    </div>
                                    <div class="btn-group">
                                        @if (user.CanDelete)
                                        {
                                            <button class="btn btn-outline-danger btn-sm" @onclick="() => DeleteBrokenUser(user)" disabled="@user.IsProcessing">
                                                @if (user.IsProcessing)
                                                {
                                                    <span class="spinner-border spinner-border-sm"></span>
                                                }
                                                else
                                                {
                                                    <i class="bi bi-trash"></i>
                                                }
                                                Delete
                                            </button>
                                        }
                                    </div>
                                </div>
                            }
                        </div>
                    }

                    @if (!string.IsNullOrEmpty(statusMessage))
                    {
                        <div class="alert @(isError ? "alert-danger" : "alert-success") mt-3">
                            @statusMessage
                        </div>
                    }
                </div>
                <div class="modal-footer border-secondary">
                    <button type="button" class="btn btn-secondary" @onclick="Close">Close</button>
                    <button type="button" class="btn btn-warning" @onclick="ScanForBrokenUsers" disabled="@isLoading">
                        <i class="bi bi-arrow-clockwise"></i> Rescan
                    </button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public bool Show { get; set; }
    [Parameter] public EventCallback<bool> ShowChanged { get; set; }

    private List<BrokenUser> brokenUsers = new();
    private bool isLoading = false;
    private string statusMessage = "";
    private bool isError = false;

    protected override async Task OnParametersSetAsync()
    {
        if (Show && !isLoading && !brokenUsers.Any())
        {
            await ScanForBrokenUsers();
        }
    }

    private async Task ScanForBrokenUsers()
    {
        isLoading = true;
        statusMessage = "";
        isError = false;
        brokenUsers.Clear();
        StateHasChanged();

        try
        {
            Logger.LogInformation("Starting scan for broken users...");

            // Get all users including raw entities to detect issues
            var allUsers = await UserRepository.GetAllUsersAsync();
            var usernameGroups = new Dictionary<string, List<User>>();

            foreach (var user in allUsers)
            {
                // Check for empty TwitchUserId
                if (string.IsNullOrWhiteSpace(user.TwitchUserId))
                {
                    brokenUsers.Add(new BrokenUser
                    {
                        TwitchUserId = user.TwitchUserId ?? "",
                        Username = user.Username ?? "(unknown)",
                        DisplayName = user.DisplayName ?? "",
                        IssueDescription = "Empty TwitchUserId - this record is orphaned and should be deleted",
                        CanDelete = true,
                        UserEntity = user
                    });
                    Logger.LogWarning("Found user with empty TwitchUserId: {Username}", user.Username);
                    continue;
                }

                // Track for duplicate detection
                var key = (user.Username ?? "").ToLowerInvariant();
                if (!string.IsNullOrEmpty(key))
                {
                    if (!usernameGroups.ContainsKey(key))
                        usernameGroups[key] = new List<User>();
                    usernameGroups[key].Add(user);
                }

                // Check for missing required fields
                if (string.IsNullOrWhiteSpace(user.Username))
                {
                    brokenUsers.Add(new BrokenUser
                    {
                        TwitchUserId = user.TwitchUserId,
                        Username = "(no username)",
                        DisplayName = user.DisplayName ?? "",
                        IssueDescription = "Missing username - user data is incomplete",
                        CanDelete = true,
                        UserEntity = user
                    });
                    Logger.LogWarning("Found user with empty Username: TwitchUserId={TwitchUserId}", user.TwitchUserId);
                }
            }

            // Check for duplicates (same username, different TwitchUserId)
            foreach (var group in usernameGroups.Where(g => g.Value.Count > 1))
            {
                Logger.LogWarning("Found duplicate username: {Username} with {Count} entries", group.Key, group.Value.Count);

                // Find the "primary" one (most recent login or has more data)
                var sorted = group.Value
                    .OrderByDescending(u => u.LastLogin)
                    .ThenByDescending(u => !string.IsNullOrEmpty(u.DisplayName) ? 1 : 0)
                    .ToList();

                var primary = sorted.First();

                foreach (var duplicate in sorted.Skip(1))
                {
                    // Only add if not already in the list
                    if (!brokenUsers.Any(b => b.TwitchUserId == duplicate.TwitchUserId))
                    {
                        brokenUsers.Add(new BrokenUser
                        {
                            TwitchUserId = duplicate.TwitchUserId,
                            Username = duplicate.Username ?? "(unknown)",
                            DisplayName = duplicate.DisplayName ?? "",
                            IssueDescription = $"Duplicate of user '{primary.Username}' (TwitchUserId: {primary.TwitchUserId}) - older/less complete record",
                            CanDelete = true,
                            UserEntity = duplicate
                        });
                    }
                }
            }

            Logger.LogInformation("Scan complete. Found {Count} broken users", brokenUsers.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error scanning for broken users");
            statusMessage = $"Error scanning: {ex.Message}";
            isError = true;
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task DeleteBrokenUser(BrokenUser user)
    {
        user.IsProcessing = true;
        statusMessage = "";
        isError = false;
        StateHasChanged();

        try
        {
            Logger.LogInformation("Attempting to delete broken user: TwitchUserId={TwitchUserId}, Username={Username}",
                user.TwitchUserId, user.Username);

            // For users with empty TwitchUserId, we need to delete by the actual entity
            if (string.IsNullOrWhiteSpace(user.TwitchUserId))
            {
                // This is the orphaned record case - need to delete directly from table
                await UserRepository.DeleteUserByRowKeyAsync(user.TwitchUserId ?? "");
                Logger.LogInformation("Deleted orphaned user record");
            }
            else
            {
                // Normal delete by TwitchUserId
                await UserRepository.DeleteUserAsync(user.TwitchUserId);
                Logger.LogInformation("Deleted user with TwitchUserId: {TwitchUserId}", user.TwitchUserId);
            }

            brokenUsers.Remove(user);
            statusMessage = $"Successfully deleted user: {user.Username}";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error deleting broken user: {TwitchUserId}", user.TwitchUserId);
            statusMessage = $"Error deleting user: {ex.Message}";
            isError = true;
        }
        finally
        {
            user.IsProcessing = false;
            StateHasChanged();
        }
    }

    private async Task Close()
    {
        Show = false;
        brokenUsers.Clear();
        statusMessage = "";
        await ShowChanged.InvokeAsync(false);
    }

    public class BrokenUser
    {
        public string TwitchUserId { get; set; } = "";
        public string Username { get; set; } = "";
        public string DisplayName { get; set; } = "";
        public string IssueDescription { get; set; } = "";
        public bool CanDelete { get; set; } = false;
        public bool IsProcessing { get; set; } = false;
        public User? UserEntity { get; set; }
    }
}
