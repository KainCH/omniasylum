@page "/overlay/{TwitchUserId}"
@layout OmniForge.Web.Components.Layout.OverlayLayout
@using OmniForge.Core.Entities
@using OmniForge.Core.Interfaces
@using System.Text.Json
@using System.Text.RegularExpressions
@using Microsoft.AspNetCore.WebUtilities
@inject NavigationManager NavigationManager
@inject ICounterRepository CounterRepository
@inject IUserRepository UserRepository
@inject IAlertRepository AlertRepository
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">

@if (errorMessage != null)
{
    <div class="error">@errorMessage</div>
}
else if (user == null || counter == null)
{
    <div class="loading">Loading...</div>
}
else if (!user.Features.StreamOverlay)
{
    <div class="error">Stream overlay not enabled for this user</div>
}
else
{
    @if (user.OverlaySettings?.TimerEnabled == true)
    {
        <div class="overlay-timer" style="@GetTimerStyle()">
            <span class="timer-label" style="color: @(user.OverlaySettings?.Theme?.BorderColor ?? "#d4af37")">TIME</span>
            <span class="timer-value" style="color: @(user.OverlaySettings?.Theme?.TextColor ?? "white")">00:00:00</span>
        </div>
    }

    <div class="counter-overlay" style="@GetPositionStyle()">
        @if (user.OverlaySettings?.Counters?.Deaths == true)
        {
            <div class="counter-item deaths" style="@GetItemStyle()">
                <div class="counter-icon">ðŸ’€</div>
                <div class="counter-info">
                    <div class="counter-label" style="color: @(user.OverlaySettings?.Theme?.BorderColor ?? "#d4af37")">DEATHS</div>
                    <div class="counter-value" style="color: @(user.OverlaySettings?.Theme?.TextColor ?? "white")">@counter.Deaths</div>
                </div>
            </div>
        }

        @if (user.OverlaySettings?.Counters?.Swears == true)
        {
            <div class="counter-item swears" style="@GetItemStyle()">
                <div class="counter-icon">ðŸ¤¬</div>
                <div class="counter-info">
                    <div class="counter-label" style="color: @(user.OverlaySettings?.Theme?.BorderColor ?? "#d4af37")">SWEARS</div>
                    <div class="counter-value" style="color: @(user.OverlaySettings?.Theme?.TextColor ?? "white")">@counter.Swears</div>
                </div>
            </div>
        }

        @if (user.OverlaySettings?.Counters?.Screams == true)
        {
            <div class="counter-item screams" style="@GetItemStyle()">
                <div class="counter-icon">ðŸ˜±</div>
                <div class="counter-info">
                    <div class="counter-label" style="color: @(user.OverlaySettings?.Theme?.BorderColor ?? "#d4af37")">SCREAMS</div>
                    <div class="counter-value" style="color: @(user.OverlaySettings?.Theme?.TextColor ?? "white")">@counter.Screams</div>
                </div>
            </div>
        }

        @if (user.OverlaySettings?.Counters?.Bits == true)
        {
            <div class="counter-item bits" style="@GetItemStyle()">
                <div class="counter-icon">ðŸ’Ž</div>
                <div class="counter-info">
                    <div class="counter-label" style="color: @(user.OverlaySettings?.Theme?.BorderColor ?? "#d4af37")">STREAM BITS</div>
                    <div class="counter-value" style="color: @(user.OverlaySettings?.Theme?.TextColor ?? "white")">@counter.Bits</div>
                    @if (user.OverlaySettings?.BitsGoal != null && user.OverlaySettings.BitsGoal.Target > 0)
                    {
                        <div class="bits-goal-progress">
                            <div class="goal-label" style="color: @(user.OverlaySettings?.Theme?.BorderColor ?? "#d4af37")">
                                Goal: @user.OverlaySettings!.BitsGoal.Current / @user.OverlaySettings!.BitsGoal.Target
                            </div>
                            <div class="goal-bar">
                                <div class="goal-fill" style="width: @(Math.Min(100, ((double)user.OverlaySettings!.BitsGoal.Current / user.OverlaySettings!.BitsGoal.Target) * 100))%"></div>
                            </div>
                        </div>
                    }
                </div>
            </div>
        }
    </div>

    <!-- Alert popup -->
    <div class="counter-alert" id="alert-popup"></div>

    <!-- Bits celebration container -->
    <div class="bits-celebration" id="bits-celebration"></div>

    <!-- Subscriber celebration container -->
    <div class="sub-celebration" id="sub-celebration"></div>

    <!-- Subscriber banner -->
    <div class="sub-banner" id="sub-banner"></div>

    <!-- Interaction banner (admin-only feature for now) -->
    <div class="interaction-banner hide" id="interaction-banner" style="@GetInteractionBannerPositionStyle()"></div>
}

<style>
    html, body {
        background: transparent !important;
        background-color: transparent !important;
        background-image: none !important;
        margin: 0;
        padding: 20px;
        font-family: 'Arial', sans-serif;
        overflow: hidden;
    }

    .counter-overlay {
        display: flex;
        flex-direction: column;
        gap: 15px;
        position: fixed;
    }

    /* Timer-only element (no box; transparent for OBS/Streamlabs browser sources) */
    .overlay-timer {
        position: fixed;
        display: flex;
        align-items: baseline;
        gap: 10px;
        background: transparent;
        padding: 0;
        margin: 0;
        user-select: none;
        -webkit-user-select: none;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.85);
        font-variant-numeric: tabular-nums;
        font-feature-settings: "tnum";
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .overlay-timer .timer-label {
        font-weight: 700;
        letter-spacing: 0.08em;
        font-size: 16px;
        opacity: 0.95;
    }

    .overlay-timer .timer-value {
        font-weight: 800;
        font-size: 28px;
        line-height: 1;
    }

    .counter-item {
        padding: 15px 25px;
        border-radius: 10px;
        backdrop-filter: blur(5px);
        display: flex;
        align-items: center;
        gap: 15px;
        min-width: 200px;
        transition: all 0.3s ease;
    }

    .counter-item:hover {
        transform: scale(1.05);
    }

    .counter-icon {
        font-size: 2rem;
        width: 40px;
        text-align: center;
    }

    .counter-info {
        flex: 1;
    }

    .counter-label {
        font-size: 1rem;
        margin-bottom: 5px;
        font-weight: bold;
    }

    .counter-value {
        font-size: 2rem;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        font-family: 'Creepster', cursive;
    }

    /* Bits Goal Progress */
    .bits-goal-progress {
        margin-top: 8px;
    }

    .goal-label {
        font-size: 0.8rem;
        margin-bottom: 4px;
        opacity: 0.9;
    }

    .goal-bar {
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        overflow: hidden;
    }

    .goal-fill {
        height: 100%;
        background: linear-gradient(90deg, #9146ff, #772ce8);
        border-radius: 3px;
        transition: width 0.3s ease;
        box-shadow: 0 0 8px rgba(145, 70, 255, 0.5);
    }

    /* Alert animations */
    .counter-alert {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #8b4513, #d4af37);
        color: white;
        padding: 30px 50px;
        border-radius: 20px;
        font-size: 3rem;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        z-index: 1000;
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
        transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    .counter-alert.show {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }

    .counter-alert.hide {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1.2);
    }

    .interaction-banner {
        position: fixed;
        left: 50%;
        transform: translateX(-50%) scale(0.5);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #d4af37;
        border-radius: 12px;
        padding: 12px 18px;
        color: white;
        font-size: 22px;
        font-weight: bold;
        opacity: 0;
        transition: all 0.35s ease;
        z-index: 950;
        pointer-events: none;
        min-width: 300px;
        text-align: center;
    }

    .interaction-banner.show {
        opacity: 1;
        transform: translateX(-50%) scale(1);
    }

    .interaction-banner.hide {
        opacity: 0;
        transform: translateX(-50%) scale(0.5);
    }

    /* Pulse animation for counter updates */
    .counter-pulse {
        animation: pulse 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    @@keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }

    /* Bits celebration effect */
    .bits-celebration {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 999;
    }

    .bit-particle {
        position: absolute;
        width: 10px;
        height: 10px;
        background: #d4af37;
        border-radius: 50%;
        animation: bitsFall 3s linear forwards;
    }

    @@keyframes bitsFall {
        0% {
            transform: translateY(-20px) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: translateY(100vh) rotate(360deg);
            opacity: 0;
        }
    }

    /* Subscriber celebration effects */
    .sub-celebration {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1001;
    }

    .sub-heart {
        position: absolute;
        font-size: 2rem;
        color: #9146ff;
        animation: subHeartFloat 4s ease-out forwards;
    }

    @@keyframes subHeartFloat {
        0% {
            transform: translateY(100vh) scale(0);
            opacity: 1;
        }
        20% {
            transform: translateY(70vh) scale(1.2);
            opacity: 1;
        }
        100% {
            transform: translateY(-20vh) scale(0.8);
            opacity: 0;
        }
    }

    .sub-banner {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #9146ff, #ff6b6b);
        color: white;
        padding: 20px 40px;
        border-radius: 15px;
        font-size: 1.5rem;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        z-index: 1002;
        opacity: 0;
        transform: translateX(-50%) translateY(-100px) scale(0.5);
        transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    .sub-banner.show {
        opacity: 1;
        transform: translateX(-50%) translateY(0) scale(1);
    }

    .sub-banner.hide {
        opacity: 0;
        transform: translateX(-50%) translateY(-100px) scale(0.5);
    }
</style>

@code {
    [Parameter]
    public string TwitchUserId { get; set; } = string.Empty;

    private OmniForge.Core.Entities.Counter? counter;
    private OmniForge.Core.Entities.User? user;
    private string StreamStatus { get; set; } = "offline";
    private bool IsPreviewMode { get; set; } = false;
    private List<Alert> alerts = new();
    private IJSObjectReference? jsModule;
    private string? errorMessage;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            user = await UserRepository.GetUserAsync(TwitchUserId);
            if (user != null)
            {
                counter = await CounterRepository.GetCountersAsync(TwitchUserId);
                StreamStatus = user.StreamStatus;

                // Determine preview mode via query param or overlay settings
                try
                {
                    var uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
                    var query = Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseQuery(uri.Query);
                    if (query.TryGetValue("preview", out var previewValues) && previewValues.ToString().Equals("true", StringComparison.OrdinalIgnoreCase))
                    {
                        IsPreviewMode = true;
                    }
                }
                catch { /* ignore query parsing errors */ }

                if (user.OverlaySettings?.OfflinePreview == true)
                {
                    IsPreviewMode = true;
                }

                if (IsPreviewMode)
                {
                    StreamStatus = "live";
                }

                alerts = (await AlertRepository.GetAlertsAsync(TwitchUserId)).ToList();
            }
            else
            {
                errorMessage = "User not found.";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error loading overlay data: {ex.Message}";
            Console.WriteLine($"[Overlay] Error in OnInitializedAsync: {ex}");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && user != null && user.Features.StreamOverlay)
        {
            try
            {
                // Retry logic for overlayInterop.init
                int retries = 0;
                while (retries < 10)
                {
                    try
                    {
                        await JSRuntime.InvokeVoidAsync("overlayInterop.init");
                        break;
                    }
                    catch (JSException)
                    {
                        retries++;
                        if (retries >= 10) throw;
                        await Task.Delay(200);
                    }
                }

                // Initialize WebSocket connection via JS
                var wsUrl = NavigationManager.ToAbsoluteUri($"/ws/overlay?userId={TwitchUserId}").ToString().Replace("http", "ws");

                // Use a try-catch block specifically for the module import to handle potential network issues or file not found errors
                try
                {
                    jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/overlay-websocket.js");
                    await jsModule.InvokeVoidAsync("connect", wsUrl, DotNetObjectReference.Create(this));
                }
                catch (JSException jsEx)
                {
                     Console.WriteLine($"[Overlay] JS Import Error: {jsEx.Message}");
                     // Fallback or retry logic could go here if needed
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[Overlay] Error in OnAfterRenderAsync: {ex}");
            }
        }
    }

    [JSInvokable]
    public void OnCounterUpdate(OmniForge.Core.Entities.Counter updatedCounter)
    {
        counter = updatedCounter;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnStreamStatusUpdate(string status)
    {
        StreamStatus = status;
        StateHasChanged();
    }

    [JSInvokable]
    public async Task OnAlert(string type, object data)
    {
        await TriggerAlert(type, data);
    }

    [JSInvokable]
    public async Task OnCustomAlert(string type, object data)
    {
        await TriggerAlert(type, data);
    }

    [JSInvokable]
    public void OnBitsGoalUpdate(OmniForge.Core.Entities.BitsGoal goal)
    {
        if (user?.OverlaySettings != null)
        {
            user.OverlaySettings.BitsGoal = goal;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void OnBitsGoalComplete(OmniForge.Core.Entities.BitsGoal goal)
    {
        if (user?.OverlaySettings != null)
        {
            user.OverlaySettings.BitsGoal = goal;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void OnMilestoneReached(object data)
    {
        // Handled by JS mostly, but we could log or update state if needed
    }

    [JSInvokable]
    public void OnStreamStarted(object data)
    {
        StreamStatus = "live";
        StateHasChanged();
    }

    [JSInvokable]
    public void OnOverlaySettingsUpdate(OmniForge.Core.Entities.OverlaySettings settings)
    {
        if (user != null)
        {
            user.OverlaySettings = settings;
            StateHasChanged();
        }
    }

    private async Task TriggerAlert(string type, object data)
    {
        if (string.Equals(type, "interactionBanner", StringComparison.OrdinalIgnoreCase))
        {
            string? text = null;
            int? duration = null;

            try
            {
                if (data is JsonElement interactionJson)
                {
                    if (interactionJson.TryGetProperty("textPrompt", out var prompt))
                    {
                        text = prompt.GetString();
                    }
                    else if (interactionJson.TryGetProperty("text", out var textProp))
                    {
                        text = textProp.GetString();
                    }

                    if (interactionJson.TryGetProperty("duration", out var durationProp) && durationProp.ValueKind == JsonValueKind.Number)
                    {
                        duration = durationProp.GetInt32();
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error parsing interaction banner: {ex.Message}");
            }

            if (!string.IsNullOrWhiteSpace(text))
            {
                await JSRuntime.InvokeVoidAsync("overlayInterop.showInteractionBanner", text, duration ?? 5000);
            }

            return;
        }

        var alert = alerts.FirstOrDefault(a => a.Type == type && a.IsEnabled);
        if (alert == null) return;

        var payload = new Dictionary<string, object>
        {
            ["id"] = alert.Id,
            ["type"] = alert.Type,
            ["name"] = alert.Name,
            ["visualCue"] = alert.VisualCue,
            ["sound"] = alert.Sound,
            ["soundDescription"] = alert.SoundDescription,
            ["textPrompt"] = alert.TextPrompt,
            ["duration"] = alert.Duration,
            ["backgroundColor"] = alert.BackgroundColor,
            ["textColor"] = alert.TextColor,
            ["borderColor"] = alert.BorderColor
        };

        try
        {
            if (!string.IsNullOrEmpty(alert.Effects))
            {
                var effectsObj = JsonSerializer.Deserialize<object>(alert.Effects);
                if (effectsObj != null)
                {
                    payload["effects"] = effectsObj;
                }
            }
        }
        catch {}

        // Merge data into payload
        if (data is JsonElement jsonElement)
        {
             var json = jsonElement.GetRawText();
             var dataDict = JsonSerializer.Deserialize<Dictionary<string, object>>(json);
             if (dataDict != null)
             {
                 foreach (var kvp in dataDict)
                 {
                     if (!payload.ContainsKey(kvp.Key))
                     {
                         payload[kvp.Key] = kvp.Value;
                     }
                 }
             }
        }

        // Apply placeholder substitution after we have merged event data.
        if (payload.TryGetValue("textPrompt", out var promptObj) && promptObj is string templatePrompt && !string.IsNullOrWhiteSpace(templatePrompt))
        {
            payload["textPrompt"] = ApplyTemplate(templatePrompt, payload);
        }

        await JSRuntime.InvokeVoidAsync("overlayInterop.triggerAlert", type, payload);
    }

    private static string ApplyTemplate(string template, IReadOnlyDictionary<string, object> payload)
    {
        string GetString(string key)
        {
            if (!payload.TryGetValue(key, out var value) || value == null) return string.Empty;
            if (value is JsonElement je)
            {
                if (je.ValueKind == JsonValueKind.String) return je.GetString() ?? string.Empty;
                return je.ToString();
            }
            return value.ToString() ?? string.Empty;
        }

        string GetNumberString(string key)
        {
            if (!payload.TryGetValue(key, out var value) || value == null) return string.Empty;
            if (value is JsonElement je)
            {
                if (je.ValueKind == JsonValueKind.Number) return je.ToString();
                if (je.ValueKind == JsonValueKind.String) return je.GetString() ?? string.Empty;
                return je.ToString();
            }
            return value.ToString() ?? string.Empty;
        }

        // Build token map (case-insensitive).
        var tokens = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            ["User"] = FirstNonEmpty(GetString("user"), GetString("displayName"), GetString("name"), GetString("gifterName"), GetString("raiderName")),
            ["Tier"] = GetString("tier"),
            ["Months"] = GetNumberString("months"),
            ["Amount"] = FirstNonEmpty(GetNumberString("amount"), GetNumberString("bits")),
            ["Viewers"] = FirstNonEmpty(GetNumberString("viewers"), GetNumberString("viewerCount")),
            ["Recipient"] = FirstNonEmpty(GetString("recipientName"), GetString("recipient")),
            ["Message"] = GetString("message"),
            ["Level"] = GetNumberString("level"),
            ["Percent"] = GetNumberString("percent")
        };

        return Regex.Replace(template, "\\[(?<token>[A-Za-z]+)\\]", match =>
        {
            var token = match.Groups["token"].Value;
            if (tokens.TryGetValue(token, out var replacement) && !string.IsNullOrEmpty(replacement))
            {
                return replacement;
            }
            return match.Value;
        });
    }

    private static string FirstNonEmpty(params string[] values)
    {
        return values.FirstOrDefault(v => !string.IsNullOrWhiteSpace(v)) ?? string.Empty;
    }

    private string GetPositionStyle()
    {
        if (user?.OverlaySettings == null) return "";

        var pos = user.OverlaySettings.Position ?? "top-right";
        var style = "";

        // Check for standard presets
        switch (pos.ToLower())
        {
            case "top-right":
                style = "top: 20px; right: 20px;";
                break;
            case "top-left":
                style = "top: 20px; left: 20px;";
                break;
            case "bottom-right":
                style = "bottom: 20px; right: 20px;";
                break;
            case "bottom-left":
                style = "bottom: 20px; left: 20px;";
                break;
            case "top-center":
                style = "top: 20px; left: 50%; transform: translateX(-50%);";
                break;
            case "bottom-center":
                style = "bottom: 20px; left: 50%; transform: translateX(-50%);";
                break;
            default:
                // If it contains CSS syntax (colon or semicolon), treat as custom CSS
                if (pos.Contains(":") || pos.Contains(";"))
                {
                    style = pos;
                }
                else
                {
                    // Fallback to legacy logic for unknown simple strings
                    style += pos.Contains("top") ? "top: 20px;" : "bottom: 20px;";
                    style += pos.Contains("right") ? "right: 20px;" : "left: 20px;";
                }
                break;
        }

        style += StreamStatus == "live" ? " opacity: 1;" : " opacity: 0;";

        return style;
    }

    private string GetTimerStyle()
    {
        var scale = user?.OverlaySettings?.Scale ?? 1.0;

        // Requirement: timer is always top-center.
        // Keep opacity behavior consistent with the main overlay.
        var opacity = StreamStatus == "live" ? "1" : "0";
        return $"top: 20px; left: 50%; transform: translateX(-50%) scale({scale}); transform-origin: top center; opacity: {opacity};";
    }

    private string GetInteractionBannerPositionStyle()
    {
        if (user?.OverlaySettings == null) return string.Empty;

        var pos = (user.OverlaySettings.Position ?? "top-right").ToLowerInvariant();
        var countersAreTop = pos.Contains("top");

        // Banner should appear opposite the counters (top vs bottom).
        return countersAreTop
            ? "bottom: 20px;"
            : "top: 20px;";
    }

    private string GetItemStyle()
    {
        if (user?.OverlaySettings?.Theme == null) return "";

        var theme = user.OverlaySettings.Theme;
        var style = $"background: {theme.BackgroundColor ?? "rgba(0, 0, 0, 0.7)"}; border: 2px solid {theme.BorderColor ?? "#d4af37"};";

        if (user.OverlaySettings.Animations?.Enabled == true)
        {
            style += " transition: all 0.3s ease;";
        }

        return style;
    }

    public async ValueTask DisposeAsync()
    {
        if (jsModule != null)
        {
            try
            {
                await jsModule.DisposeAsync();
            }
            catch (Microsoft.JSInterop.JSDisconnectedException)
            {
                // Ignore, circuit is already dead
            }
            catch (Exception)
            {
                // Ignore other disposal errors
            }
        }
    }
}
