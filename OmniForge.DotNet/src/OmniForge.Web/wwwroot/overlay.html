<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OmniForge Overlay</title>
  <link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/overlay.css">
  <style>
    /* Basic Reset & Overlay Styles */
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: transparent;
      /* Crucial for OBS */
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    .counter-overlay {
      position: absolute;
      display: flex;
      flex-direction: column;
      gap: 10px;
      transition: opacity 1s ease-in-out;
      opacity: 0;
      /* Default hidden until stream starts */
    }

    .counter-overlay.visible {
      opacity: 1;
    }

    .counter-item {
      display: flex;
      align-items: center;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #d4af37;
      border-radius: 8px;
      padding: 8px 12px;
      color: white;
      min-width: 150px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .counter-item.custom {
      cursor: pointer;
    }

    .counter-icon {
      font-size: 24px;
      margin-right: 10px;
    }

    .counter-info {
      display: flex;
      flex-direction: column;
    }

    .counter-label {
      font-size: 12px;
      font-weight: bold;
      color: #d4af37;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .counter-value {
      font-size: 24px;
      font-weight: bold;
      line-height: 1.2;
    }

    /* Alert Popup Styles */
    .counter-alert {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.5);
      background: rgba(0, 0, 0, 0.9);
      border: 3px solid #d4af37;
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      opacity: 0;
      transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      z-index: 1000;
      pointer-events: none;
      min-width: 300px;
    }

    .counter-alert.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .alert-title {
      font-family: 'Creepster', cursive;
      font-size: 36px;
      color: #d4af37;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    .alert-message {
      font-size: 24px;
      color: white;
    }

    .alert-image {
      max-width: 100%;
      max-height: 200px;
      margin-bottom: 15px;
      display: none;
      /* Hidden by default */
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
    }

    .alert-image.show {
      display: block;
    }

    /* Celebration Containers */
    .bits-celebration,
    .sub-celebration {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 900;
    }

    .interaction-banner {
      position: fixed;
      left: 50%;
      transform: translateX(-50%) scale(0.5);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #d4af37;
      border-radius: 12px;
      padding: 12px 18px;
      color: white;
      font-size: 22px;
      font-weight: bold;
      opacity: 0;
      transition: all 0.35s ease;
      z-index: 950;
      pointer-events: none;
      min-width: 300px;
      text-align: center;
    }

    .interaction-banner.show {
      opacity: 1;
      transform: translateX(-50%) scale(1);
    }

    .interaction-banner.hide {
      opacity: 0;
      transform: translateX(-50%) scale(0.5);
    }
  </style>
</head>

<body>
  <script>
    // Silence alert sounds briefly on load/refresh
    window.omniSilenceInitialMs = 3000;
    // Set the suppression window immediately so refresh/reconnect doesn't play sounds
    window.omniSilenceUntil = Date.now() + window.omniSilenceInitialMs;
  </script>
  <div id="overlay-container" class="counter-overlay">
    <!-- Counters will be injected here -->
  </div>

  <div class="interaction-banner hide" id="interaction-banner"></div>

  <div class="counter-alert alert-container" id="alert-popup">
    <img id="alert-image" class="alert-image" src="" alt="Alert Visual" />
    <div class="alert-title" id="alert-title">ALERT</div>
    <div class="alert-message" id="alert-message">Message</div>
  </div>

  <div class="bits-celebration" id="bits-celebration"></div>
  <div class="sub-celebration" id="sub-celebration"></div>

  <!-- Scripts -->
  <script src="/js/asylum-effects.js"></script>
  <script src="/js/notification-audio.js"></script>
  <script src="/js/overlay-interop.js"></script>
  <script>
    // Main Overlay Logic
    (function () {
      const urlParams = new URLSearchParams(window.location.search);
      const userId = urlParams.get('userId');
      const preview = urlParams.get('preview') === 'true';

      // Used by overlay-interop.js and overlay-websocket.js (when present)
      window.omniOverlayPreview = preview;
      // Optional: `&debug=true` enables additional console logging.
      // Keep default silent to avoid OBS log noise.
      const debug = urlParams.get('debug') === 'true';
      window.omniOverlayDebug = debug;

      // Store current overlay settings for filtering counters
      let currentSettings = null;
      // Store last counter data for re-rendering when settings change
      let lastCounterData = null;

      // Store active custom counters config (per-game), keyed by counterId
      let customCountersConfig = {};

      // Stream timer state (pure client-side; OBS friendly)
      let timerIntervalId = null;
      let streamStartMs = null;
      let timerDurationSeconds = 0;
      let manualRunning = false;
      let manualStartMs = null;
      let timerExpired = false;
      let lastKnownIsLive = false;
      let lastOnlineSignalAtMs = null;

      // Visibility should be driven by active online signals.
      // If the monitor stops sending updates, the overlay should auto-hide.
      const LIVE_SIGNAL_TTL_MS = 120000; // 2 minutes

      const isLiveSignalFresh = () => {
        if (!lastOnlineSignalAtMs) return false;
        return (Date.now() - lastOnlineSignalAtMs) < LIVE_SIGNAL_TTL_MS;
      };

      const parseToMs = (value) => {
        if (!value) return null;
        if (typeof value === 'string') {
          const ms = Date.parse(value);
          return Number.isFinite(ms) ? ms : null;
        }
        if (typeof value === 'number') {
          if (!Number.isFinite(value)) return null;
          // Heuristic: interpret numeric values as either milliseconds or seconds since epoch
          // by choosing the interpretation that is closest to the current time.
          const now = Date.now();
          const asMs = value;
          const asMsFromSeconds = value * 1000;
          const diffMs = Math.abs(asMs - now);
          const diffSeconds = Math.abs(asMsFromSeconds - now);
          return diffSeconds < diffMs ? asMsFromSeconds : asMs;
        }
        if (typeof value === 'object' && value.dateTime) {
          const ms = Date.parse(value.dateTime);
          return Number.isFinite(ms) ? ms : null;
        }
        return null;
      };

      const updateOverlayContainerVisibility = () => {
        const container = document.getElementById('overlay-container');
        if (!container) return;

        const offlinePreview = window.omniOverlayOfflinePreview === true;
        const shouldShow = preview || offlinePreview || manualRunning || isLiveSignalFresh();

        if (shouldShow) {
          container.classList.add('visible');
        } else {
          container.classList.remove('visible');
        }
      };

      const pad2 = (n) => String(n).padStart(2, '0');
      const formatMmSs = (seconds) => {
        const safe = Math.max(0, Number(seconds) || 0);
        const m = Math.floor(safe / 60);
        const s = safe % 60;
        return `${pad2(m)}:${pad2(s)}`;
      };

      const shouldForceVisible = () => {
        return preview === true || window.omniOverlayOfflinePreview === true || manualRunning === true;
      };

      const updateTimerVisibility = () => {
        const timerEl = document.querySelector('.overlay-timer');
        if (!timerEl) return;

        window.omniOverlayTimerExpired = timerExpired;

        const isVisible = !timerExpired && (shouldForceVisible() || isLiveSignalFresh());
        timerEl.style.opacity = isVisible ? '1' : '0';
      };

      const updateTimerDisplay = () => {
        const valueEl = document.querySelector('.overlay-timer .timer-value');
        if (!valueEl) return;

        const start = (manualRunning && manualStartMs) ? manualStartMs : streamStartMs;
        if (!start) {
          valueEl.textContent = '00:00';
          return;
        }

        const elapsedSeconds = Math.floor(Math.max(0, Date.now() - start) / 1000);

        if (timerDurationSeconds > 0) {
          const remainingSeconds = Math.max(0, timerDurationSeconds - elapsedSeconds);
          valueEl.textContent = formatMmSs(remainingSeconds);

          if (remainingSeconds <= 0) {
            // Countdown completed: fade back to hidden.
            if (!timerExpired) {
              try {
                if (window.notificationAudio && typeof window.notificationAudio.playNotification === 'function') {
                  window.notificationAudio.playNotification('timerFinished');
                }
              } catch (e) { }
            }
            timerExpired = true;
            window.omniOverlayTimerExpired = true;
            stopTimerInterval();
            updateTimerVisibility();
          }
          return;
        }

        // Elapsed timer mode
        timerExpired = false;
        window.omniOverlayTimerExpired = false;
        valueEl.textContent = formatMmSs(elapsedSeconds);
      };

      const startTimerInterval = () => {
        if (timerIntervalId) return;
        // Keep timer display + visibility in lockstep.
        timerIntervalId = setInterval(() => {
          updateTimerDisplay();
          updateTimerVisibility();
          updateOverlayContainerVisibility();
        }, 1000);
      };

      const stopTimerInterval = () => {
        if (!timerIntervalId) return;
        clearInterval(timerIntervalId);
        timerIntervalId = null;
      };

      const applyTimerSettings = (settings) => {
        if (!settings) return;

        const durationMinutes = Number(settings.timerDurationMinutes ?? settings.TimerDurationMinutes ?? 0);
        timerDurationSeconds = Number.isFinite(durationMinutes) && durationMinutes > 0 ? Math.floor(durationMinutes * 60) : 0;

        manualRunning = (settings.timerManualRunning ?? settings.TimerManualRunning) === true;
        window.omniOverlayTimerForceVisible = manualRunning;

        if (manualRunning) {
          timerExpired = false;
          window.omniOverlayTimerExpired = false;
          const parsed = parseToMs(settings.timerManualStartUtc ?? settings.TimerManualStartUtc);
          manualStartMs = parsed || Date.now();
          startTimerInterval();
        } else {
          manualStartMs = null;
        }

        updateTimerVisibility();
        updateTimerDisplay();
      };

      // Apply a safe default immediately so we don't rely on inline CSS.
      // This keeps the overlay positioned even if no settings are returned yet.
      currentSettings = { position: 'top-right', scale: 1 };
      applySettings(currentSettings);

      if (!userId) {
        // Avoid innerHTML to keep CodeQL happy and prevent DOM XSS patterns.
        const message = document.createElement('div');
        message.setAttribute('style', 'color: red; background: black; padding: 20px;');
        message.textContent = 'Error: No userId provided in URL query parameter.';
        document.body.replaceChildren(message);
        return;
      }

      // Initialize interop early so any incoming messages during startup are suppressed
      if (window.overlayInterop) {
        window.overlayInterop.init();

        // In preview mode, ensure the timer element exists immediately for testing
        // (even if TimerEnabled is currently off in persisted settings).
        if (preview && window.overlayInterop.updateOverlaySettings) {
          window.overlayInterop.updateOverlaySettings(currentSettings || { scale: 1, position: 'top-right' });
        }
      }

      // Initial Data Load
      fetch(`/api/counters/${userId}`)
        .then(response => response.json())
        .then(data => {
          console.log("üì• Initial data loaded:", JSON.stringify(data));
          if (data.settings) {
            currentSettings = data.settings;
            console.log("‚öôÔ∏è Loaded settings:", JSON.stringify(currentSettings));
            applySettings(data.settings);

            if (window.overlayInterop && window.overlayInterop.updateOverlaySettings) {
              window.overlayInterop.updateOverlaySettings(data.settings);
            }

            applyTimerSettings(data.settings);
          }

          // Load custom counter definitions if present
          customCountersConfig = data.customCountersConfig || data.CustomCountersConfig || {};

          updateCounters(data);
        })
        .catch(err => console.error("Error loading initial data:", err));

      // Server Instance ID tracking for silent refresh on server restart
      let knownServerInstanceId = null;
      let reconnectAttempts = 0;
      let isHealthCheckInProgress = false; // Prevent concurrent health checks
      let healthCheckFailures = 0; // Track consecutive health check failures
      const MAX_RECONNECT_BEFORE_HEALTH_CHECK = 3;
      const MAX_HEALTH_CHECK_FAILURES = 5; // After this many failures, show warning

      async function checkServerRestart() {
        // Prevent concurrent health checks to avoid race conditions
        if (isHealthCheckInProgress) {
          console.log("‚è≥ Health check already in progress, skipping...");
          return;
        }

        isHealthCheckInProgress = true;
        try {
          const response = await fetch('/health');
          const data = await response.json();

          // Reset failure counter on success
          healthCheckFailures = 0;

          if (knownServerInstanceId === null) {
            // First time - store the server instance ID
            knownServerInstanceId = data.serverInstanceId;
            console.log("üîë Server instance ID stored:", knownServerInstanceId);
          } else if (data.serverInstanceId !== knownServerInstanceId) {
            // Server has restarted - refresh the page silently
            console.log("üîÑ Server restart detected! Old:", knownServerInstanceId, "New:", data.serverInstanceId);
            console.log("üîÑ Refreshing overlay silently...");
            window.location.reload();
          }
          // Note: reconnectAttempts is reset in the WebSocket onopen handler, and only if no new reconnect attempts
          // were initiated during this health check (see the conditional guard in the onopen logic).
        } catch (err) {
          healthCheckFailures++;
          console.warn(`‚ö†Ô∏è Health check failed (${healthCheckFailures}/${MAX_HEALTH_CHECK_FAILURES}):`, err.message);

          if (healthCheckFailures >= MAX_HEALTH_CHECK_FAILURES) {
            console.error("‚ùå Multiple health check failures. Server may be down or network issues.");
          }
        } finally {
          isHealthCheckInProgress = false;
        }
      }

      // Initial health check to get server instance ID
      checkServerRestart();

      // WebSocket Connection
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws/overlay?userId=${userId}`;

      let socket;

      function connect() {
        socket = new WebSocket(wsUrl);

        socket.onopen = function () {
          console.log("Connected to Overlay WebSocket");
          // Reset health check failure counter on successful connection
          healthCheckFailures = 0;
          // Check for server restart on successful reconnect
          if (reconnectAttempts > 0) {
            console.log("üîç Checking for server restart after reconnection...");
            const attemptsBeforeCheck = reconnectAttempts;
            checkServerRestart()
              .finally(() => {
                // Only reset if no new reconnect attempts occurred during the health check
                if (reconnectAttempts === attemptsBeforeCheck) {
                  reconnectAttempts = 0;
                }
              });
          }
          // Note: No else block needed - reconnectAttempts is already 0 on initial connection
        };

        socket.onmessage = function (event) {
          try {
            const msg = JSON.parse(event.data);
            handleMessage(msg);
          } catch (e) {
            console.error("Error parsing WS message:", e);
          }
        };

        socket.onclose = function (event) {
          console.log("WebSocket closed. code=", event.code, "reason=", event.reason, "clean=", event.wasClean, "Reconnecting in 5s...");
          reconnectAttempts++;

          // After multiple reconnect attempts, check if server restarted
          // Note: Health check is informational only here - reconnectAttempts reset happens in onopen
          if (reconnectAttempts >= MAX_RECONNECT_BEFORE_HEALTH_CHECK && !isHealthCheckInProgress) {
            console.log("üîç Multiple reconnect attempts, checking server health...");
            // Don't await - let reconnect continue while health check runs
            checkServerRestart();
          }

          setTimeout(connect, 5000);
        };

        socket.onerror = function (err) {
          console.error("WebSocket error:", err);
          socket.close();
        };
      }

      connect();

      // Watchdog: if the monitor stops sending online heartbeats, auto-hide.
      // This runs even when no websocket messages are incoming.
      setInterval(() => {
        updateOverlayContainerVisibility();

        if (!manualRunning) {
          if (isLiveSignalFresh() && streamStartMs) {
            startTimerInterval();
          } else {
            stopTimerInterval();
          }
        }

        updateTimerVisibility();
      }, 5000);

      function handleMessage(msg) {
        console.log("üì® WebSocket message received:", JSON.stringify(msg));
        const { method, data } = msg;

        switch (method) {
          case 'counterUpdate':
            console.log("üìä Counter update:", JSON.stringify(data));
            updateCounters(data);
            break;
          case 'overlaySettingsUpdate':
          case 'settingsUpdate':
            console.log("‚öôÔ∏è Settings update via WebSocket:", JSON.stringify(data));
            currentSettings = data;
            applySettings(data);

            if (window.overlayInterop && window.overlayInterop.updateOverlaySettings) {
              window.overlayInterop.updateOverlaySettings(data);
            }

            applyTimerSettings(data);
            // Re-render counters with new settings filter
            if (lastCounterData) {
              console.log("üîÑ Re-rendering counters with new settings filter");
              updateCounters(lastCounterData);
            }
            break;
          case 'streamStarted':
            console.log("üü¢ Stream started! Data:", JSON.stringify(data), "streamStarted value:", data.streamStarted);
            updateCounters(data);

            // Treat streamStarted as an initial live heartbeat.
            // Twitch may not re-send stream.online on reconnect, and the server may not yet have sent streamStatusUpdate.
            lastKnownIsLive = true;
            lastOnlineSignalAtMs = Date.now();
            updateOverlayContainerVisibility();
            updateTimerVisibility();
            break;
          case 'streamEnded':
            console.log("üî¥ Stream ended! Data:", JSON.stringify(data));
            updateCounters(data);

            if (!manualRunning) {
              streamStartMs = null;
              lastKnownIsLive = false;
              lastOnlineSignalAtMs = null;
              stopTimerInterval();
              updateTimerVisibility();
              updateTimerDisplay();
            }
            break;
          case 'streamStatusUpdate':
            console.log("üì∫ Stream status update:", JSON.stringify(data));
            {
              const status = (data && (data.streamStatus ?? data.StreamStatus)) ?? data;
              if (typeof status === 'string') {
                const normalized = status.toLowerCase();
                const isLive = normalized === 'live';
                lastKnownIsLive = isLive;

                if (isLive) {
                  lastOnlineSignalAtMs = Date.now();
                } else if (normalized === 'offline') {
                  // Explicit offline signal should immediately hide.
                  lastOnlineSignalAtMs = null;
                  if (!manualRunning) {
                    streamStartMs = null;
                    stopTimerInterval();
                    updateTimerDisplay();
                  }
                }
              }

              updateOverlayContainerVisibility();
              updateTimerVisibility();
            }
            break;
          case 'ping':
            // Ignore ping messages
            break;
          case 'customAlert':
            // WebSocketOverlayNotifier sends custom alerts as: { alertType, data }
            if (data && data.alertType) {
              // These are control-plane updates, not user-facing alerts.
              if (data.alertType === 'chatCommandsUpdated') {
                // Overlay does not render chat commands; this message is for backend/bot sync.
                // Treat as silent to avoid showing a default "ALERT" popup during game switches.
                if (window.omniOverlayDebug === true) {
                  console.log('üõ†Ô∏è Control-plane: chatCommandsUpdated', JSON.stringify(data.data || {}));
                }
                return;
              }

              if (data.alertType === 'customCountersUpdated') {
                if (window.omniOverlayDebug === true) {
                  console.log('üõ†Ô∏è Control-plane: customCountersUpdated', JSON.stringify(data.data || {}));
                }
                customCountersConfig = (data.data && data.data.counters) ? data.data.counters : {};
                if (lastCounterData) {
                  updateCounters(lastCounterData);
                }
                return;
              }

              if (data.alertType === 'customCounterUpdate') {
                if (window.omniOverlayDebug === true) {
                  console.log('üõ†Ô∏è Control-plane: customCounterUpdate', JSON.stringify(data.data || {}));
                }
                // Update cached lastCounterData's customCounters if possible
                const counterId = data.data?.counterId;
                const value = data.data?.value;
                if (counterId && value !== null && value !== undefined) {
                  if (!lastCounterData) lastCounterData = {};
                  if (!lastCounterData.customCounters) lastCounterData.customCounters = {};
                  lastCounterData.customCounters[counterId] = value;
                  updateCounters(lastCounterData);
                }
                return;
              }

              // Everything else is an actual alert
              if (window.overlayInterop) {
                window.overlayInterop.triggerAlert(data.alertType, data.data || {});
              }
            }
            break;
          default:
            console.log("üîî Alert message:", method, JSON.stringify(data));
            // Handle alerts
            if (window.overlayInterop) {
              window.overlayInterop.triggerAlert(method, data);
            }
            break;
        }
      }

      function applySettings(settings) {
        const container = document.getElementById('overlay-container');
        const interactionBanner = document.getElementById('interaction-banner');

        // Handle both camelCase (standard) and PascalCase (fallback) properties
        const rawScale = settings ? (settings.scale ?? settings.Scale) : 1;
        const rawPosition = settings ? (settings.position || settings.Position) : 'top-right';

        const scale = (rawScale != null) ? Number(rawScale) : 1;
        const position = rawPosition ? String(rawPosition) : 'top-right';

        // Expose offline-preview flag to other scripts (timer visibility)
        window.omniOverlayOfflinePreview = settings?.offlinePreview === true || settings?.OfflinePreview === true;

        // Reset position styles
        container.style.top = '';
        container.style.bottom = '';
        container.style.left = '';
        container.style.right = '';

        if (interactionBanner) {
          interactionBanner.style.top = '';
          interactionBanner.style.bottom = '';
        }

        // Compute position + translate
        let translate = '';
        switch (position) {
          case 'top-left':
            container.style.top = '20px';
            container.style.left = '20px';
            container.style.transformOrigin = 'top left';
            if (interactionBanner) interactionBanner.style.bottom = '20px';
            break;
          case 'top-right':
            container.style.top = '20px';
            container.style.right = '20px';
            container.style.transformOrigin = 'top right';
            if (interactionBanner) interactionBanner.style.bottom = '20px';
            break;
          case 'bottom-left':
            container.style.bottom = '20px';
            container.style.left = '20px';
            container.style.transformOrigin = 'bottom left';
            if (interactionBanner) interactionBanner.style.top = '20px';
            break;
          case 'bottom-right':
            container.style.bottom = '20px';
            container.style.right = '20px';
            container.style.transformOrigin = 'bottom right';
            if (interactionBanner) interactionBanner.style.top = '20px';
            break;
          case 'top-center':
            container.style.top = '20px';
            container.style.left = '50%';
            translate = 'translateX(-50%)';
            container.style.transformOrigin = 'top center';
            if (interactionBanner) interactionBanner.style.bottom = '20px';
            break;
          case 'bottom-center':
            container.style.bottom = '20px';
            container.style.left = '50%';
            translate = 'translateX(-50%)';
            container.style.transformOrigin = 'bottom center';
            if (interactionBanner) interactionBanner.style.top = '20px';
            break;
          case 'custom':
            // Custom positioning is handled elsewhere (if used)
            break;
          default:
            // Fallback to top-right
            container.style.top = '20px';
            container.style.right = '20px';
            container.style.transformOrigin = 'top right';
            if (interactionBanner) interactionBanner.style.bottom = '20px';
            break;
        }

        // Apply transform (combine translate + scale so centering doesn't clobber scale)
        const safeScale = Number.isFinite(scale) && scale > 0 ? scale : 1;
        container.style.transform = translate ? `${translate} scale(${safeScale})` : `scale(${safeScale})`;
      }

      function updateCounters(data) {
        const container = document.getElementById('overlay-container');
        console.log("üîÑ updateCounters called with:", JSON.stringify(data));
        console.log("üîç streamStarted check:", data.streamStarted, "truthy:", !!data.streamStarted);
        console.log("‚öôÔ∏è Current settings for filtering:", JSON.stringify(currentSettings));

        // Store last counter data for re-rendering when settings change
        lastCounterData = data;

        // Handle visibility based on stream status.
        // IMPORTANT: Some WS payloads omit streamStarted after certain events (e.g., game switch).
        // We only change stream start state when the payload explicitly includes the streamStarted field.
        const offlinePreview = window.omniOverlayOfflinePreview === true;
        const hasStreamStartedField = !!data && (
          Object.prototype.hasOwnProperty.call(data, 'streamStarted')
          || Object.prototype.hasOwnProperty.call(data, 'StreamStarted')
        );

        if (hasStreamStartedField) {
          const raw = (data.streamStarted !== undefined ? data.streamStarted : data.StreamStarted);

          // Semantics:
          // - `streamStarted: <valid timestamp>` => online signal (refresh TTL)
          // - `streamStarted: null` => explicitly offline
          // - `streamStarted` present but invalid/non-null => ignore (don't spuriously flip offline)
          if (raw === null) {
            streamStartMs = null;
            lastKnownIsLive = false;
            lastOnlineSignalAtMs = null;
          } else {
            const parsedStart = parseToMs(raw);
            if (parsedStart) {
              streamStartMs = parsedStart;
              lastKnownIsLive = true;
              lastOnlineSignalAtMs = Date.now();
              timerExpired = false;
              window.omniOverlayTimerExpired = false;
            }
          }
        }

        const isStreamStarted = preview || offlinePreview || manualRunning || isLiveSignalFresh();

        if (isStreamStarted) {
          console.log("‚úÖ Adding 'visible' class to container");
          container.classList.add('visible');
        } else {
          console.log("‚ùå Removing 'visible' class from container");
          container.classList.remove('visible');
        }

        // Stream timer start time (used when not manually running)
        if (!manualRunning) {
          if (isLiveSignalFresh() && streamStartMs) {
            startTimerInterval();
          } else {
            stopTimerInterval();
          }
          updateTimerVisibility();
          updateTimerDisplay();
        }

        // Clear current (avoid innerHTML)
        container.replaceChildren();

        // Normalize payload shapes (public endpoint vs Counter entity)
        const deaths = (data.deaths !== undefined ? data.deaths : data.Deaths);
        const swears = (data.swears !== undefined ? data.swears : data.Swears);
        const screams = (data.screams !== undefined ? data.screams : data.Screams);
        const bits = (data.bits !== undefined ? data.bits : data.Bits);
        const customCounters = (data.customCounters || data.CustomCounters || {});

        // Get counter visibility settings (default to true if not specified)
        // Handle both camelCase and PascalCase
        const countersConfig = (currentSettings?.counters) || (currentSettings?.Counters) || {};
        const showDeaths = (countersConfig.deaths !== undefined ? countersConfig.deaths : countersConfig.Deaths) !== false; // Default true
        const showSwears = (countersConfig.swears !== undefined ? countersConfig.swears : countersConfig.Swears) !== false; // Default true
        const showScreams = (countersConfig.screams !== undefined ? countersConfig.screams : countersConfig.Screams) !== false; // Default true
        const showBits = (countersConfig.bits === true || countersConfig.Bits === true); // Default false for bits

        console.log("üìã Counter visibility - Deaths:", showDeaths, "Swears:", showSwears, "Screams:", showScreams, "Bits:", showBits);

        // Only show counters that are enabled in settings
        if (showDeaths && deaths !== undefined) createCounterItem(container, 'DEATHS', deaths, 'üíÄ');
        if (showSwears && swears !== undefined) createCounterItem(container, 'SWEARS', swears, 'ü§¨');
        if (showScreams && screams !== undefined) createCounterItem(container, 'SCREAMS', screams, 'üò±');
        if (showBits && bits !== undefined) createCounterItem(container, 'BITS', bits, 'üíé');

        // Render custom counters configured for the active game
        renderCustomCounters(container, customCounters);
      }

      function renderCustomCounters(container, customCounters) {
        const defs = customCountersConfig || {};
        const entries = Object.entries(defs);

        if (!entries.length) return;

        // Sort by display name for stable rendering
        entries.sort((a, b) => {
          const nameA = (a[1]?.name || a[1]?.Name || a[0]).toString().toLowerCase();
          const nameB = (b[1]?.name || b[1]?.Name || b[0]).toString().toLowerCase();
          return nameA.localeCompare(nameB);
        });

        for (const [counterId, def] of entries) {
          const label = def?.name || def?.Name || counterId;
          const icon = def?.icon || def?.Icon || 'üî¢';
          const value = (customCounters && (customCounters[counterId] ?? customCounters[counterId.toLowerCase()])) ?? 0;

          createCustomCounterItem(container, counterId, label, value, icon);
        }
      }

      function createCounterItem(container, label, value, icon) {
        // Validate that value is numeric (CWE-20: Improper Input Validation)
        if (value === null || value === undefined || isNaN(Number(value))) {
          console.warn(`Invalid non-numeric value received for ${label}:`, value);
          value = 0;
        }

        const div = document.createElement('div');
        div.className = 'counter-item';

        const iconDiv = document.createElement('div');
        iconDiv.className = 'counter-icon';
        iconDiv.textContent = icon;

        const infoDiv = document.createElement('div');
        infoDiv.className = 'counter-info';

        const labelDiv = document.createElement('div');
        labelDiv.className = 'counter-label';
        labelDiv.textContent = label;

        const valueDiv = document.createElement('div');
        valueDiv.className = 'counter-value';
        valueDiv.textContent = value;

        infoDiv.appendChild(labelDiv);
        infoDiv.appendChild(valueDiv);

        div.appendChild(iconDiv);
        div.appendChild(infoDiv);

        container.appendChild(div);
      }

      function createCustomCounterItem(container, counterId, label, value, icon) {
        // Reuse the same item structure but mark as custom and attach click-to-increment
        const div = document.createElement('div');
        div.className = 'counter-item custom';
        div.setAttribute('data-counter-id', counterId);

        const iconDiv = document.createElement('div');
        iconDiv.className = 'counter-icon';
        iconDiv.textContent = icon;

        const infoDiv = document.createElement('div');
        infoDiv.className = 'counter-info';

        const labelDiv = document.createElement('div');
        labelDiv.className = 'counter-label';
        labelDiv.textContent = label;

        const valueDiv = document.createElement('div');
        valueDiv.className = 'counter-value';
        valueDiv.textContent = (value === null || value === undefined || isNaN(Number(value))) ? '0' : String(value);

        infoDiv.appendChild(labelDiv);
        infoDiv.appendChild(valueDiv);

        div.appendChild(iconDiv);
        div.appendChild(infoDiv);

        div.addEventListener('click', async () => {
          try {
            await fetch(`/api/counters/${userId}/custom/${encodeURIComponent(counterId)}/increment`, {
              method: 'POST'
            });
            // No need to update DOM here; the server will broadcast a counterUpdate over WS.
          } catch (err) {
            console.error('‚ùå Failed to increment custom counter:', counterId, err);
          }
        });

        container.appendChild(div);
      }

      // Interop already initialized above
    })();
  </script>
</body>

</html>
