{"type":"entity","name":"Azure Deployment Process","entityType":"deployment_procedure","observations":["OmniAsylum Stream Counter is deployed to Azure Container Apps in resource group 'Streamer-Tools-RG'","Uses Azure Container Registry 'omniforgeacr' to store Docker images","Container app name is 'omniforgestream-api-prod' running in South Central US region","Deployment URL: https://omniforgestream-api-prod.proudplant-8dc6fe7a.southcentralus.azurecontainerapps.io","Uses Azure Key Vault 'forge-steel-vault' for secrets management","Storage account 'omni46jismtjodyuc' for Table Storage data persistence","Application Insights 'omniforgestream-insights-prod' for monitoring","Deployment uses existing Bicep infrastructure in deploy/main.bicep","Container Apps environment manages scaling and networking automatically","Uses HTTPS with automatic certificate management","WebSocket support enabled with TCP scaling rules","Environment variables are managed through Azure Key Vault","Database mode switches automatically to 'azure' in production"]}
{"type":"entity","name":"Docker Build Process","entityType":"build_procedure","observations":["Build Docker image locally first: 'docker build -t omniforgestream-api:latest .'","Login to Azure Container Registry: 'az acr login --name omniforgeacr'","Tag image for registry: 'docker tag omniforgestream-api:latest omniforgeacr.azurecr.io/omniforgestream-api:latest'","Push to registry: 'docker push omniforgeacr.azurecr.io/omniforgestream-api:latest'","Always test Docker build locally before pushing to ensure it works properly","Build process must be run from the API directory: cd 'c:\\Game Data\\Coding Projects\\doc-omni\\API'","Dockerfile uses Node.js 20 Alpine for smaller image size","Production dependencies are installed with 'npm ci --only=production'","Image includes all JavaScript files and frontend directory","Non-root user 'node' is used for security","Data directory is created with proper permissions"]}
{"type":"entity","name":"Azure Container App Update","entityType":"deployment_procedure","observations":["Update running container app: 'az containerapp update --name omniforgestream-api-prod --resource-group Streamer-Tools-RG --image omniforgeacr.azurecr.io/omniforgestream-api:latest'","Container app auto-scales from 0-5 instances based on demand","Uses managed identity 'bears-stream-UAMI' for secure access to Azure resources","Target port 3000 matches application listening port","WebSocket scaling rules configured for real-time connections"]}
{"type":"entity","name":"Authentication Fix Process","entityType":"troubleshooting_procedure","observations":["Fixed 401 admin authentication errors by correcting requireAdmin middleware","Changed requireAdmin to not call requireAuth internally to prevent double authentication","Updated all admin routes to use both 'requireAuth, requireAdmin' middleware chain","Admin routes now properly validate JWT tokens before checking admin role","Added new admin endpoint GET /api/admin/streams for stream session monitoring","Issue was caused by requireAdmin middleware calling requireAuth internally","Double authentication created middleware conflicts and 401 errors","Solution was to make requireAdmin expect req.user to already be set","All admin routes now explicitly use both middlewares in order","JWT token validation happens first, then admin role checking","Added proper error messages to distinguish auth vs authorization failures"]}
{"type":"entity","name":"Deployment Verification Steps","entityType":"testing_procedure","observations":["Test health endpoint: 'curl https://omniforgestream-api-prod.proudplant-8dc6fe7a.southcentralus.azurecontainerapps.io/api/health'","Check container logs: 'az containerapp logs show --name omniforgestream-api-prod --resource-group Streamer-Tools-RG --tail 10'","Verify overlay endpoint works (returns HTML): '/overlay/{userId}'","Confirm WebSocket connections show in logs: 'connected: Username (ID)'","Admin panel should load without 401 errors after authentication fixes"]}
{"type":"entity","name":"Azure Resources Structure","entityType":"infrastructure","observations":["Resource Group: Streamer-Tools-RG in South Central US","Container Registry: omniforgeacr for image storage","Container App: omniforgestream-api-prod with external ingress","Key Vault: forge-steel-vault stores Twitch secrets and JWT secret","Storage Account: omni46jismtjodyuc for Table Storage (users/counters)","Log Analytics: omniforgestream-logs-prod for application logging","Application Insights: omniforgestream-insights-prod for monitoring","Managed Identity: bears-stream-UAMI for passwordless resource access"]}
{"type":"entity","name":"Stream Integration Features","entityType":"feature_set","observations":["Bits counter with stream session reset functionality","Real-time WebSocket overlay for OBS browser source integration","Subscriber celebration animations with animated overlays","Stream session management with !startstream and !endstream commands","Moderator permissions for stream control commands","Configurable bit celebration thresholds per user","Public commands: !bits, !streamstats for viewers","Admin stream monitoring endpoint showing active sessions"]}
{"type":"entity","name":"OBS Overlay Integration","entityType":"streaming_feature","observations":["Browser source URL format: https://domain/overlay/{userId}","Real-time counter updates via WebSocket connections","Animated celebration effects for bits and subscribers","Transparent background for overlay compatibility","CSS animations for counter changes and alerts","Responsive design works on all stream layouts","Supports death counter, swear counter, and bits display"]}
{"type":"entity","name":"Stream Command System","entityType":"chat_integration","observations":["Moderator commands: !startstream, !endstream, !resetbits","Counter commands for mods: !death+, !death-, !swear+, !swear-","Public viewer commands: !deaths, !swears, !bits, !stats, !streamstats","Commands work for both broadcaster and moderators","Stream session tracking with automatic bits counter reset","Integration with Twitch chat via Twurple library","Permission checking via Twitch userInfo flags (isBroadcaster, isMod)"]}
{"type":"entity","name":"OmniAsylum Stream Counter","entityType":"Project","observations":["Multi-tenant Twitch stream counter application deployed to Azure Container Apps","Node.js backend with Express + Socket.io, vanilla HTML/CSS/JavaScript frontend","Azure Table Storage for production, local JSON files for development","Twitch OAuth 2.0 authentication with JWT tokens, admin user is 'riress'","Current production deployment: omniforgestream-api-prod.proudplant-8dc6fe7a.southcentralus.azurecontainerapps.io","WebSocket rooms per user for real-time synchronization across devices","Comprehensive RBAC system with feature flags per user","DEPLOYMENT STATUS: Currently running on omniforgestream-api-prod--11042001 (November 4, 2025 deployment)","RECENT FIXES: Database update methods fixed to use proper field-specific updates instead of full user recreation","PRODUCTION HEALTH: API endpoints responding correctly, feature toggles working properly","ACTIVE FEATURES: Bits integration fully operational, stream overlay customization deployed","STREAM DETECTION: EventSub WebSocket stream monitoring working automatically for all active users","NEXT DEPLOYMENT: Ready for channel points integration implementation","INFRASTRUCTURE: Azure Container Apps, Azure Table Storage, Azure Key Vault all operational","SERVER STATUS: Development server running successfully on localhost:3000","MISSING CREDENTIALS: Twitch app credentials not configured (graceful handling)","REWARDS STORAGE: Local rewards.json file created for development","API ENDPOINTS: All reward management endpoints accessible and functional","WEBSOCKET EVENTS: Real-time reward redemption events ready for overlay integration","ADMIN INTERFACE: Full rewards management UI with create/delete functionality"]}
{"type":"entity","name":"Channel Points Integration","entityType":"Feature Implementation Plan","observations":["PRIORITY: High Impact - leverages existing EventSub infrastructure in streamMonitor.js","CURRENT STATE: Feature flag exists (channelPoints: false) but ZERO implementation","PLAN: Add EventSub subscription for 'channel.channel_point_custom_reward_redemption.add' events","IMPLEMENTATION: Create custom rewards via Twitch API (e.g., 'Add Death' for 100 points, 'Add Swear' for 50 points)","TECHNICAL: Extend streamMonitor.js setupEventHandlers() to include reward redemption listeners","UI COMPONENTS: Add reward management section to admin dashboard for creating/managing custom rewards","DATABASE: Add channelPointRewards table to store custom reward configurations per user","WEBSOCKET: Add 'rewardRedeemed' event type for real-time overlay notifications","STEP 1: Extend streamMonitor.js - Add this.listener.onChannelRedemption() handler in setupEventHandlers()","STEP 2: Create custom rewards via Twitch API - Add createCustomReward() method in streamMonitor.js","STEP 3: Database schema - Add channelPointRewards table with columns: userId, rewardId, rewardTitle, cost, action, isEnabled","STEP 4: Admin UI - Add reward management section to AdminDashboard.jsx with create/edit/delete functionality","STEP 5: API routes - Add /api/admin/rewards endpoints for CRUD operations on custom rewards","STEP 6: Event handling - Add handleRewardRedemption() method to process redemptions and trigger counter actions","STEP 7: WebSocket events - Emit 'rewardRedeemed' events to overlay for visual feedback","STEP 8: Feature flag integration - Ensure channelPoints feature flag gates all functionality","IMPLEMENTATION STATUS: Channel Points functionality fully implemented and deployed","EVENTSUB INTEGRATION: Extended streamMonitor.js with onChannelRedemptionAdd handler","DATABASE SCHEMA: Added channelPointRewards table with full CRUD operations","API ROUTES: Created /api/rewards endpoints for reward management (GET, POST, DELETE)","ADMIN UI: Extended AdminDashboard.jsx with comprehensive rewards management interface","EVENT HANDLING: Added reward redemption and counter update event broadcasting","GRACEFUL FALLBACK: Stream monitor handles missing Twitch credentials without crashing","LOCAL DEVELOPMENT: All components working in development mode with local JSON storage"]}
{"type":"entity","name":"Enhanced Alert System","entityType":"Feature Implementation Plan","observations":["PRIORITY: Medium Impact - builds on existing celebration animation system","CURRENT STATE: Counter alerts and bits alerts implemented, subscriber placeholders exist","MISSING: EventSub subscriptions for follows, subscriptions, raids, and gift subscriptions","PLAN: Add EventSub listeners for channel.follow, channel.subscribe, channel.raid events","TECHNICAL: Extend streamMonitor.js with new event handlers for Twitch events","OVERLAY: Build on existing celebrateSubscriber() function in overlayRoutes.js","ANIMATIONS: Create follow celebration effects, raid alert with viewer count, tier-based sub celebrations","FEATURE FLAG: Already gated by 'alertAnimations' feature flag","STEP 1: Add EventSub subscriptions in streamMonitor.js for channel.follow, channel.subscribe, channel.raid","STEP 2: Implement event handlers - handleFollowEvent(), handleSubscriptionEvent(), handleRaidEvent()","STEP 3: Extend overlay animations - Create followCelebration(), raidAlert(), tierBasedSubCelebration() functions","STEP 4: Audio integration - Add sound effects for different alert types (follow beep, sub chime, raid horn)","STEP 5: Customization options - Add alert settings to user overlay configuration (enable/disable per alert type)","STEP 6: Database tracking - Optionally store alert history for analytics if analytics feature flag enabled","STEP 7: WebSocket events - Emit follow/sub/raid events to connected clients for real-time updates"]}
{"type":"entity","name":"Webhook Integration System","entityType":"Feature Implementation Plan","observations":["PRIORITY: Low Impact - external service integration capability","CURRENT STATE: Feature flag exists (webhooks: false) but no implementation","PLAN: Create webhook delivery system for counter updates and events","IMPLEMENTATION: Add webhookRoutes.js for webhook management, webhook delivery queue","TECHNICAL: Support POST requests to external URLs with counter data on events","ADMIN UI: Webhook configuration interface for adding/managing webhook endpoints","SECURITY: Implement webhook signature validation and retry logic for failed deliveries","USE CASES: Integration with StreamElements, StreamLabs, Discord bots, custom dashboards","STEP 1: Create webhookRoutes.js with CRUD endpoints for webhook management","STEP 2: Database schema - Add webhooks table with userId, url, events, secret, isActive, createdAt","STEP 3: Webhook delivery service - Create webhookDelivery.js with queue system and retry logic","STEP 4: Event triggers - Integrate webhook calls into counter update events and Twitch events","STEP 5: Admin UI - Add webhook management interface to AdminDashboard.jsx","STEP 6: Security - Implement HMAC signature validation for webhook authenticity","STEP 7: Testing tools - Add webhook testing functionality to verify endpoint connectivity","STEP 8: Rate limiting - Implement delivery rate limits to prevent spam to external services"]}
{"type":"entity","name":"EventSub Infrastructure","entityType":"Technical Foundation","observations":["STATUS: Production-ready and fully implemented in streamMonitor.js","CAPABILITIES: WebSocket connection management, app authentication with refreshing tokens","CURRENT EVENTS: Stream online/offline detection with automatic session management","MULTI-TENANT: Supports monitoring multiple users simultaneously with individual subscriptions","AUTO-FEATURES: Automatic stream session initialization when user goes live","EXPANSION READY: Foundation exists to add more EventSub event types easily","RATE LIMITING: Includes delay mechanisms to avoid Twitch API rate limits"]}
{"type":"entity","name":"Bits Integration System","entityType":"Completed Feature","observations":["STATUS: Fully production-ready and deployed","CHAT DETECTION: Auto-detects bits from Twitch chat via TMI.js in multiTenantTwitchService.js","COUNTER TRACKING: Separate bits counter that resets when stream starts automatically","CELEBRATIONS: Animated falling particles on overlay (1 particle per bit, max 50 particles)","THRESHOLDS: Configurable via stream settings (death: 100 bits, swear: 50 bits, celebration: 10 bits)","COMMANDS: !bits and !resetbits chat commands available to mods/broadcaster","FEATURE GATING: Controlled by 'bitsIntegration' feature flag per user","REAL-TIME: WebSocket 'bitsReceived' events for live overlay updates"]}
{"type":"entity","name":"OmniAsylum Stream Counter Enhancement Plan","entityType":"development_plan","observations":["Complete redesign of user status system from binary Active/Inactive to multi-state streamStatus: 'offline' | 'prepping' | 'live' | 'ending'","Phase 1: Enhanced Status System - Database schema update with streamStatus field, new API endpoints /api/stream/prep, /api/stream/go-live, /api/stream/end, enhanced UI with 4-state status indicator","Phase 2: Stream State Integration - EventSub auto-detection for real Twitch stream status, auto-transitions between states, overlay updates for each status mode","Phase 3: Dedicated Bot Account - Separate Twitch app/account for Doctor Bot, bot joins streamers' channels with permissions, custom bot personality and responses","Current system gaps identified: Missing prepping status, binary status system, manual activation only, using user account instead of dedicated bot","Prepping Mode Features: Start Prepping button sets status to prepping, starts Twitch bot/chat monitoring, begins stream state polling, enables overlay with Getting Ready message","Auto Stream Detection: EventSub integration detects live/offline status, auto-transition from prepping to live when stream detected, auto-transition from live to offline when stream ends","Dedicated Doctor Bot Account: Separate Twitch account for Doctor Bot for the Asylum, bot joins user channels instead of using user credentials, bot responds with medical personality theme","Implementation priority: Phase 1 provides immediate Start Prepping button and proper state management foundation","User specifically requested prepping status functionality - a button to set preparing to stream state","User wants actual Doctor Bot for the Asylum to respond to chat commands instead of using broadcaster's account","Current overlay shows 'Overlay is currently disabled' message even when streamOverlay feature is enabled","Chat commands not working because no Twitch bots are connected (connectedUsers: 0 from /api/twitch/status)","Overlay fixed to use simplified logic: Feature enabled + User active = Overlay shows","System needs auto-detection of stream going live/offline with EventSub integration","Implementation should start with Phase 1 for immediate prepping button functionality","Medical/asylum theme should be incorporated into bot responses and personality"]}
{"type":"entity","name":"Current System Architecture","entityType":"system_analysis","observations":["Multi-tenant Twitch service manages one bot per authenticated streamer using their own credentials","Stream monitor service exists with EventSub WebSocket for real-time notifications","Admin dashboard has self-activation capability with Activate Myself button","Overlay system checks streamOverlay feature + user isActive status for display","Chat commands working: !deaths, !swears, !stats (public), !d+, !d-, !s+, !s-, !resetcounters (mods/broadcaster only)","Database supports Azure Table Storage with users and counters tables","Real-time WebSocket connections for counter updates and user status changes","Current status system: isActive boolean field only, no intermediate states","Deployment successful to Azure Container Apps with revision 11042331","Health endpoint working: status ok, uptime 186 seconds, keyVault true, dbMode azure","Twitch service initialized but no users connected currently","Admin dashboard authentication working for user riress (admin role)","Overlay route fixed to check streamStatus instead of overlay settings enabled flag","Container restart shows no startup logs for Twitch bot connections","Need to investigate why autoStartTwitchBots not triggering on server startup"]}
{"type":"entity","name":"Phase 1 Implementation Details","entityType":"technical_specification","observations":["Database schema: Add streamStatus enum field to users table alongside existing isActive boolean","New API endpoints: POST /api/stream/prep (set prepping status), POST /api/stream/go-live (manual live trigger), POST /api/stream/end (manual end)","UI enhancements: Replace binary Active/Inactive with 4-state indicator (Offline, Prepping, Live, Ending)","Button logic: Offline shows Start Prepping, Prepping shows Go Live + Cancel, Live shows End Stream, Ending shows automated transition","Overlay updates: Different messages for each state - Offline (disabled), Prepping (Getting Ready), Live (active counters), Ending (stream ended)","Auto-services: Prepping status starts Twitch bot, chat monitoring, stream detection polling","Backward compatibility: Maintain isActive field for existing logic while adding streamStatus","Database migration needed: ALTER users table ADD streamStatus ENUM('offline', 'prepping', 'live', 'ending')","Stream routes file exists but needs new endpoints for state transitions","AdminDashboard.jsx needs UI updates for new status states and buttons","Overlay logic already updated to check isActive - needs streamStatus integration","Self-activation endpoint modified to allow users to activate themselves","Need to ensure Twitch bot starts automatically when user enters prepping state","WebSocket events needed for real-time status updates to all connected clients"]}
{"type":"entity","name":"MQTT Printer Overlay Integration","entityType":"project","observations":["Integration plan for adding Bambu Labs X1C printer MQTT overlay to Forge multi-tenant Twitch overlay system","Requires two-tier architecture: local MQTT bridge + cloud Azure API integration","Local bridge needed because MQTT broker only accessible on local network, not from Azure Container Apps","Riress-streaming project contains existing MQTT implementation with TypeScript services (BambuMQTTService, WebSocketService)","Forge overlay system already has multi-tenant architecture with Socket.io, JWT auth, and per-user WebSocket rooms"]}
{"type":"entity","name":"Local MQTT Bridge Service","entityType":"component","observations":["Runs on local machine/network with access to Bambu Labs X1C printer","Connects to printer MQTT broker on port 8883 (mqtts protocol) using printer IP and access code","Reuses existing riress-streaming code (BambuMQTTService.ts, printer.ts types)","Transforms MQTT messages to REST API calls to Forge cloud API","Authenticates with Forge API using user's Twitch JWT token","Pushes printer status updates to new /api/printer/status endpoint","Lightweight service that can run as Windows service or background process","Handles printer data: temperatures, print progress, layer info, AMS filament status, fan speeds"]}
{"type":"entity","name":"Forge API Extensions for Printer Data","entityType":"component","observations":["New REST endpoint: POST /api/printer/status (authenticated, receives data from local bridge)","New REST endpoint: GET /api/printer/:userId (retrieves current printer status)","Requires new Azure Table Storage table or extend existing schema for printer data","Add feature flag '3dPrinterOverlay' to user feature flags system","Broadcast printer updates via existing Socket.io infrastructure using user rooms (user:${userId})","Socket.io event: 'printerUpdate' with payload containing printer status","Store printer status fields: temperatures (bed, nozzle, chamber), progress, layers, AMS status, fan speeds, print stage"]}
{"type":"entity","name":"Printer Overlay Frontend","entityType":"component","observations":["New overlay route: /overlay/:userId?type=printer (OBS browser source compatible)","Shows real-time 3D printer status: progress bar, temperatures, AMS filament info, time remaining","Uses existing Forge overlay styling (dark theme, clean design matching counter overlays)","Connects via Socket.io to receive real-time 'printerUpdate' events","Configurable position, theme, and display options via overlay settings API","Can display: print progress percentage, current/total layers, time elapsed/remaining, nozzle/bed/chamber temps, active filament color and type, operation status","Similar design patterns to existing riress-streaming banner.html and progress-ams.html overlays"]}
{"type":"entity","name":"Implementation Strategy","entityType":"plan","observations":["Option A (Recommended): Minimal Bridge - create lightweight local service pushing to Forge API REST endpoints","Option B: Full Local Server with Tunneling - run riress-streaming as-is with ngrok/Cloudflare Tunnel","Phase 1: Build local MQTT bridge service (Node.js/TypeScript) connecting to printer and Forge API","Phase 2: Extend Forge API with printer endpoints, storage, and Socket.io broadcasting","Phase 3: Create new printer overlay type with real-time updates","Phase 4: Add admin controls for enabling/disabling printer overlay per user","Benefits: Secure (no MQTT exposed), multi-tenant compatible, uses existing infrastructure, cloud deployment ready"]}
{"type":"entity","name":"Riress-Streaming MQTT System","entityType":"codebase","observations":["Located in riress-streaming/ folder with TypeScript implementation","BambuMQTTService connects to Bambu Labs X1C via MQTT on port 8883 with TLS","Parses 95%+ validated MQTT schema from BambuStudio source code (92 fields validated)","Handles 57 print operation codes, comprehensive AMS support with 4-tray configuration","WebSocketService broadcasts printer status to browser overlays on port 3001","Overlays available: banner.html, progress-ams.html, system-monitor.html, main.html","Config via environment variables: PRINTER_IP, PRINTER_ACCESS_CODE, PRINTER_SERIAL, MQTT_PORT","Current overlays show: filament info, operation status, progress bar, layer tracking, time remaining/elapsed"]}
{"type":"entity","name":"Discord Bot Multi-Server Notifications","entityType":"feature","observations":["Extension of Discord webhook notifications to support multiple Discord servers","Replaces single webhook approach with Discord Bot that can post to unlimited channels","Requires Discord Application with Bot user created at discord.com/developers/applications","Bot token stored securely in Azure Key Vault (DISCORD_BOT_TOKEN secret)","Uses discord.js npm library (Client, GatewayIntentBits, EmbedBuilder)","Bot needs Gateway intents: Guilds, GuildMessages","Requires message permissions: Send Messages, Embed Links, Attach Files (51200 total)","Users invite bot via OAuth2 URL: https://discord.com/api/oauth2/authorize?client_id=BOT_ID&permissions=51200&scope=bot","Each user configures array of Discord channel IDs where notifications should post","When stream goes live, bot sends rich embed to all configured channels across all servers","Bot can be in unlimited servers simultaneously (scalability)","Provides centralized control vs distributed webhook management","Enables future features: reactions, buttons, slash commands, message editing"]}
{"type":"entity","name":"Discord Bot Service","entityType":"component","observations":["New service: API/discordBotService.js using discord.js library","Singleton instance managing Discord Client connection","initialize(botToken) method logs bot into Discord Gateway","sendLiveNotification(userData, streamData, channelIds) method posts to multiple channels","Creates EmbedBuilder with stream title, game, Twitch link, profile thumbnail","Iterates through channelIds array, fetches each channel, sends message with embed","Returns results array with success/failure status per channel","Handles errors gracefully per channel (one failure doesn't block others)","Bot must be in each server where channel IDs are configured","Channel IDs are snowflake strings (e.g. '123456789012345678')","Integrated into streamMonitor.handleStreamOnline() event"]}
{"type":"entity","name":"Discord Multi-Channel Admin UI","entityType":"component","observations":["Extension of DiscordWebhookSettings.jsx component","Supports both single webhook URL and multiple channel IDs","Input for adding Discord channel IDs (one per line or comma-separated)","Instructions for finding channel ID (Enable Developer Mode, right-click channel, Copy ID)","Visual list showing all configured channels with remove buttons","Test button sends test message to all channels","Shows delivery status per channel (success/failure with error messages)","Explains bot invite process with generated OAuth2 URL","Backend API endpoints: GET/PUT /api/user/discord-channels for managing channel list"]}
{"type":"entity","name":"Discord Bot Implementation Strategy","entityType":"plan","observations":["Phase 1: Create Discord Application and Bot at discord.com/developers/applications","Phase 2: Add DISCORD_BOT_TOKEN to Azure Key Vault secrets","Phase 3: Install discord.js npm package in API folder","Phase 4: Create API/discordBotService.js with Client initialization and message sending","Phase 5: Update database schema to add discordChannelIds array field","Phase 6: Update userRoutes.js with /api/user/discord-channels endpoints (GET/PUT/POST test)","Phase 7: Update DiscordWebhookSettings.jsx to support channel IDs input","Phase 8: Integrate discordBotService into streamMonitor.handleStreamOnline()","Phase 9: Update documentation with bot setup instructions and OAuth2 invite URL","Phase 10: Test with multiple servers to verify cross-server posting","Backward compatibility: Keep existing webhook functionality alongside bot approach"]}
{"type":"relation","from":"Docker Build Process","to":"Azure Container App Update","relationType":"precedes"}
{"type":"relation","from":"Azure Deployment Process","to":"Azure Resources Structure","relationType":"utilizes"}
{"type":"relation","from":"Authentication Fix Process","to":"Deployment Verification Steps","relationType":"enables"}
{"type":"relation","from":"Stream Integration Features","to":"OBS Overlay Integration","relationType":"includes"}
{"type":"relation","from":"Stream Integration Features","to":"Stream Command System","relationType":"includes"}
{"type":"relation","from":"Azure Deployment Process","to":"Stream Integration Features","relationType":"deploys"}
{"type":"relation","from":"Deployment Verification Steps","to":"OBS Overlay Integration","relationType":"validates"}
{"type":"relation","from":"Stream Command System","to":"Authentication Fix Process","relationType":"requires"}
{"type":"relation","from":"Channel Points Integration","to":"EventSub Infrastructure","relationType":"depends on"}
{"type":"relation","from":"Enhanced Alert System","to":"EventSub Infrastructure","relationType":"extends"}
{"type":"relation","from":"Channel Points Integration","to":"OmniAsylum Stream Counter","relationType":"enhances"}
{"type":"relation","from":"Enhanced Alert System","to":"OmniAsylum Stream Counter","relationType":"enhances"}
{"type":"relation","from":"Webhook Integration System","to":"OmniAsylum Stream Counter","relationType":"extends"}
{"type":"relation","from":"Bits Integration System","to":"OmniAsylum Stream Counter","relationType":"implemented in"}
{"type":"relation","from":"EventSub Infrastructure","to":"Bits Integration System","relationType":"supports"}
{"type":"relation","from":"Channel Points Integration","to":"Enhanced Alert System","relationType":"works with"}
{"type":"relation","from":"EventSub Infrastructure","to":"OmniAsylum Stream Counter","relationType":"core component of"}
{"type":"relation","from":"OmniAsylum Stream Counter Enhancement Plan","to":"Current System Architecture","relationType":"builds_upon"}
{"type":"relation","from":"Phase 1 Implementation Details","to":"OmniAsylum Stream Counter Enhancement Plan","relationType":"implements_phase_of"}
{"type":"relation","from":"OmniAsylum Stream Counter Enhancement Plan","to":"Phase 1 Implementation Details","relationType":"requires_implementation_of"}
{"type":"relation","from":"MQTT Printer Overlay Integration","to":"Local MQTT Bridge Service","relationType":"requires"}
{"type":"relation","from":"MQTT Printer Overlay Integration","to":"Forge API Extensions for Printer Data","relationType":"requires"}
{"type":"relation","from":"MQTT Printer Overlay Integration","to":"Printer Overlay Frontend","relationType":"requires"}
{"type":"relation","from":"Local MQTT Bridge Service","to":"Riress-Streaming MQTT System","relationType":"reuses code from"}
{"type":"relation","from":"Local MQTT Bridge Service","to":"Forge API Extensions for Printer Data","relationType":"sends data to"}
{"type":"relation","from":"Forge API Extensions for Printer Data","to":"Printer Overlay Frontend","relationType":"provides data to"}
{"type":"relation","from":"Implementation Strategy","to":"MQTT Printer Overlay Integration","relationType":"defines approach for"}
{"type":"relation","from":"Discord Bot Multi-Server Notifications","to":"Discord Notifications Feature","relationType":"extends"}
{"type":"relation","from":"Discord Bot Multi-Server Notifications","to":"Discord Bot Service","relationType":"requires"}
{"type":"relation","from":"Discord Bot Multi-Server Notifications","to":"Discord Multi-Channel Admin UI","relationType":"requires"}
{"type":"relation","from":"Discord Bot Service","to":"Forge API Extensions for Printer Data","relationType":"integrates with"}
{"type":"relation","from":"Discord Bot Implementation Strategy","to":"Discord Bot Multi-Server Notifications","relationType":"defines approach for"}